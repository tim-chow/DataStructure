<h3>线索二叉树的原理</h3>
在二叉树的<em>二叉链表</em>表示中，一个有N个节点的二叉树，共有2n个指针域，其中非空指针域的数量是n - 1，空指针域的数量是2n - (n - 1) = n + 1。</br>
因此，提出一种方法，<strong>利用这些空指针域保存先序、中序或后序遍历中的前驱或后继节点</strong>。这种指针就叫<strong>线索</strong>，这样的二叉树就叫<strong>线索二叉树</strong>，创建线索二叉树的过程叫做<strong>二叉树的线索化</strong>。</br>
下面以<strong>中序线索二叉树</strong>为例，进行说明：</br>
<ul>
	<li>如果节点的左指针域为空，则将其指向中序遍历时的<strong>前驱节点</strong></li>
	<li>如果节点的右指针域为空，则将其指向中序遍历时的<strong>后继节点</strong></li>
</ul>
显然，需要一个标记位来指示：左指针域是指向左孩子，还是前驱；还需要另外一个标记位来指示，右指针域是指向右孩子，还是后继。</br>
因此，在每个节点中，增加两个标记域：ltag，rtag；当ltag为false时，表示左指针域指向左孩子，否则指向前驱；当rtag为false时，表示右指针域指向右孩子，否则指向后继。</br>
<hr></hr>
<h3>线索二叉树的构建</h3>
线索化的实质是<strong>将二叉链表的空指针域 修改为 指向前驱或后继的 线索</strong>。因为前驱和后继信息，只有在遍历的时候才能得到，所以线索化的过程 就是 <strong>在遍历的过程中，修改空指针的过程</strong>。</br>
具体思路，就是：</br>
<strong>使用一个全局变量保存<em>刚刚访问过的节点</em></strong>。然后在遍历的过程中修改空指针的指向以及标记位。</br>
<hr></hr>
<h3>中序线索二叉树的遍历</h3>
<ul>
	<li>从根节点开始一直走到最左面的节点，然后访问该节点</li>
	<li>沿着节点的后继一直向后走，并访问该路径上的每个节点，直到没有后继</li>
	<li>切换到右子树，按照上面的策略继续遍历，<strong>直到节点为空</strong></li>
</ul>
