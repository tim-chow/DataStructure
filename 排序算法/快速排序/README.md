### 快速排序算法

1. 从序列中选择一个元素作为基准元素（pivot），通常选择序列的第一个元素

* 通过一次排序将序列分成两部分，左面的部分中的所有元素都不大于基准元素，右面的部分中的所有元素都不小于基准元素，这样基准元素恰好在排序后应该在的位置上

* 以相同的方式，对左、右两部分进行排序，直到整个序列有序

---

### 时间复杂度和空间复杂度分析

**当选择的基准元素在数组的中间位置上，并且恰好是数组的中间值时**，此时只需要进行n次比较。时间复杂度是：

<pre>
T(n) = 2 * T(n / 2) + n ===&gt;
T(n) = 2 * (2 * T(n / 4) + n / 2) + n ===&gt;
T(n) = 4 * T(n / 4) + 2 * n ===&gt;
T(n) = 4 * (2 * T(n / 8) + n / 4) + 2 * n ===&gt;
T(n) = 8 * T(n / 8) + 3 * n ===&gt;
...
T(n) = 2<sup>m</sup> * T(n / 2<sup>m</sup>) + m * n

且 T(1) = 1，所以当 2<sup>m</sup> -&gt; n，即 m = log<sub>2</sub>n 时，T(n) = n + n * log<sub>2</sub>n

所以，时间复杂度是 O(nlogn)
</pre>

**当数组是倒序的，并且选择第一个元素作为基准元素时**，一次排序下来会置换 n - 1 次元素，并且数组被分为两部分，左面的部分有 n - 1 个元素，右面的部分有 0 个元素。时间复杂度是:

<pre>
T(n) = T(n - 1) + T(0) + n - 1===gt;
T(n) = (T(n - 2) + T(0) + n - 2) + T(0) + n - 1 ===&gt;
T(n) = T(n - 2) + 2 * T(0) + (n - 1) + (n - 2) ===gt;
T(n) = (T(n - 3) + T(0) + n - 3) + 2 * T(0) + (n - 1) + (n - 2) ===gt;
T(n) = T(n - 3) + 3 * T(0) + (n - 1) + (n - 2) + (n - 3) ===gt;
...
T(n) = T(n - m) + m * T(0) + (n - 1) + (n - 2) + ... + (n - m)

且 T(1) = 1，所以当 m -&gt; n - 1 时，T(n) = T(1) + (n - 1) * T(0) + (n - 1) + ... + 1 = n + n * (n - 1) / 2 = n<sup>2</sup> / 2 + n / 2

所以时间复杂度是 O(n<sup>2</sup>)
</pre>

在一趟排序中，快排耗费的空间是常数级的，但是需要递归 logn 到 n 次，所以空间复杂度在最好的情况下是 O(logn)，在最坏情况下是 O(n)。
