### 什么是堆

堆是一棵完全二叉树，并且任意非叶子节点的关键字不小于（或不大于）其孩子节点的关键字，前者叫大根堆，后者叫小根堆。

---

### 堆的基本操作（以小根堆为例）

* 建堆：  
建堆是一个不断<strong>调整堆</strong>的过程。从 length / 2 处（数组的中间位置）开始，向前调整，一直到第一个元素

* 调整堆：  
在建堆、向堆中插入元素、堆排序时，都会调整堆，其过程如下：
    * 对于某个节点：
        * 如果它是叶子节点，则<strong>调整结束</strong>
        * 如果它只有左孩子，则按需调整该节点和其左孩子的关键字，然后<strong>调整结束</strong>
        * 如果该节点的关键字不大于其左、右孩子节点的关键字，则<strong>调整结束</strong>
        * 否则，将该节点的关键字与其孩子节点的关键字中的较小者进行互换
        * 然后，从发生互换的位置，按照上面的流程，继续<strong>向下</strong>调整

---

### 堆排序

堆排序的过程如下：

1. 首先将输入数组<strong>堆化</strong>

* 交换堆的第一个元素和最后一个元素，然后将堆的最后一个元素删掉，并从堆顶开始调整堆

* 重复执行步骤2，直到堆中没有元素

---

### TopK 问题

TopK 问题是：从包含 n 个元素的数组中，找出前 k 大的元素。

解决 topk 问题的基本思路是：

1. 将数组的前 k 个元素调整成一个<strong>小根堆</strong>

* 从第 k + 1 个元素开始，逐个比较元素和堆的根的大小，如果：
    * 元素不大于堆的根，则什么也不做
    * 否则，将元素和堆的根互换，并调整堆

* 重复执行步骤2，直到比较完数组的最后一个元素

---

### 时间复杂度分析

* 建堆的时间复杂度：  
设树的深度为 k，在最坏的情况下，第 1 层（含 2<sup>0</sup> 个节点）向下调整 k - 1 次，第 2 层（含 2<sup>1</sup> 个节点）向下调整 k - 2 次，...，第 k - 1 层（含 2<sup>k-2</sup> 个节点）向下调整 1 次，因此最坏的情况下的时间复杂度是：  
2<sup>0</sup> * (k - 1) + 2<sup>1</sup> * (k - 2) + ... + 2<sup>k-2</sup> * 1 ===&gt;  
k * (2<sup>0</sup> + ... + 2<sup>k-2</sup>) - (1 * 2<sup>0</sup> + ... + (k-1) * 2<sup>k-2</sup>) ===&gt;  
k * (2<sup>k-1</sup> - 1) - ((k-1)*2<sup>k-1</sup> - 2<sup>k-1</sup> + 1) ===&gt;  
2<sup>k</sup> - k - 1  
根据完全二叉树的性质，可得到 k = floor(log<sub>2</sub>n) + 1，所以建堆的时间复杂度是O(n)

* 堆排序的时间复杂度  
在最坏的情况下，堆排序的时间复杂度是：  
log<sub>2</sub>(n-1) + log<sub>2</sub>(n-2) + ... + log<sub>2</sub>2 + log<sub>2</sub>1 ===&gt;  
log<sub>2</sub>((n-1)!)  
根据[斯特林公式](https://baike.baidu.com/item/%E6%96%AF%E7%89%B9%E6%9E%97%E5%85%AC%E5%BC%8F/9583086?fr=aladdin)，可以得到堆排序的时间复杂度是O(nlogn)

* TopK 问题的时间复杂度  
在最坏的情况下，TopK 问题的时间复杂度是：  
log<sub>2</sub>k * (n - k)  
因此，TopK 问题的时间复杂度是O(nlogk)

---

### 空间复杂度

因为堆排序是<strong>原地排序</strong>，所以在不使用递归的情况下，空间复杂度是O(1)

---

### 补充说明

* 有 n 个节点的二叉树的分支的数量是 n - 1，这些分支都是由度为 1 和度为 2 的结点射出的，所以，n<sub>1</sub> + 2 &times; n<sub>2</sub> = n - 1，结合 n<sub>0</sub> + n<sub>1</sub> + n<sub>2</sub> = n，可以推出 n<sub>0</sub> = n<sub>2</sub> + 1
    * 在完全二叉树中，度为 1 的节点，要么有 0 个（当 n 是奇数时）；要么有 1 个（当 n 是偶数时）。所以 2 &time; n<sub>0</sub> + n<sub>1</sub> - 1 = n、n<sub>0</sub> = n / 2（当 n 是偶数时）或 n<sub>0</sub> = (n + 1) / 2（当 n 是奇数时）。故在完全二叉树中，叶子节点的数量是：向上取整(n / 2)
* 设 m = a<sup>x</sup>，n = a<sup>y</sup>，则 mn = a<sup>(x+y)</sup>、x = log<sub>a</sub>m、y = log<sub>a</sub>n。所以 log<sub>a</sub>mn = log<sub>a</sub>m + log<sub>a</sub>n
* 因为 log(mn) = logm + logn，所以 logm<sup>n</sup> = log(m * m * ... * m) = logm + ... + logm = nlogm
